{
  "version": 3,
  "sources": ["../../node_modules/escape-html/index.js", "../../node_modules/interweave/src/constants.ts", "../../node_modules/interweave/src/Element.tsx", "../../node_modules/interweave/src/Filter.ts", "../../node_modules/interweave/src/match.ts", "../../node_modules/interweave/src/Matcher.ts", "../../node_modules/interweave/src/StyleFilter.ts", "../../node_modules/interweave/src/Parser.ts", "../../node_modules/interweave/src/Markup.tsx", "../../node_modules/interweave/src/Interweave.tsx"],
  "sourcesContent": ["/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n", "/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n\nimport { ConfigMap, FilterMap, NodeConfig } from './types';\n\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\nexport const TYPE_FLOW = 1;\nexport const TYPE_SECTION = 1 << 1;\nexport const TYPE_HEADING = 1 << 2;\nexport const TYPE_PHRASING = 1 << 3;\nexport const TYPE_EMBEDDED = 1 << 4;\nexport const TYPE_INTERACTIVE = 1 << 5;\nexport const TYPE_PALPABLE = 1 << 6;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst tagConfigs: Record<string, Partial<NodeConfig>> = {\n\ta: {\n\t\tcontent: TYPE_FLOW | TYPE_PHRASING,\n\t\tself: false,\n\t\ttype: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n\t},\n\taddress: {\n\t\tinvalid: [\n\t\t\t'h1',\n\t\t\t'h2',\n\t\t\t'h3',\n\t\t\t'h4',\n\t\t\t'h5',\n\t\t\t'h6',\n\t\t\t'address',\n\t\t\t'article',\n\t\t\t'aside',\n\t\t\t'section',\n\t\t\t'div',\n\t\t\t'header',\n\t\t\t'footer',\n\t\t],\n\t\tself: false,\n\t},\n\taudio: {\n\t\tchildren: ['track', 'source'],\n\t},\n\tbr: {\n\t\ttype: TYPE_FLOW | TYPE_PHRASING,\n\t\tvoid: true,\n\t},\n\tbody: {\n\t\tcontent:\n\t\t\tTYPE_FLOW |\n\t\t\tTYPE_SECTION |\n\t\t\tTYPE_HEADING |\n\t\t\tTYPE_PHRASING |\n\t\t\tTYPE_EMBEDDED |\n\t\t\tTYPE_INTERACTIVE |\n\t\t\tTYPE_PALPABLE,\n\t},\n\tbutton: {\n\t\tcontent: TYPE_PHRASING,\n\t\ttype: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n\t},\n\tcaption: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['table'],\n\t},\n\tcol: {\n\t\tparent: ['colgroup'],\n\t\tvoid: true,\n\t},\n\tcolgroup: {\n\t\tchildren: ['col'],\n\t\tparent: ['table'],\n\t},\n\tdetails: {\n\t\tchildren: ['summary'],\n\t\ttype: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE,\n\t},\n\tdd: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['dl'],\n\t},\n\tdl: {\n\t\tchildren: ['dt', 'dd'],\n\t\ttype: TYPE_FLOW,\n\t},\n\tdt: {\n\t\tcontent: TYPE_FLOW,\n\t\tinvalid: ['footer', 'header'],\n\t\tparent: ['dl'],\n\t},\n\tfigcaption: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['figure'],\n\t},\n\tfooter: {\n\t\tinvalid: ['footer', 'header'],\n\t},\n\theader: {\n\t\tinvalid: ['footer', 'header'],\n\t},\n\thr: {\n\t\ttype: TYPE_FLOW,\n\t\tvoid: true,\n\t},\n\timg: {\n\t\tvoid: true,\n\t},\n\tli: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['ul', 'ol', 'menu'],\n\t},\n\tmain: {\n\t\tself: false,\n\t},\n\tol: {\n\t\tchildren: ['li'],\n\t\ttype: TYPE_FLOW,\n\t},\n\tpicture: {\n\t\tchildren: ['source', 'img'],\n\t\ttype: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED,\n\t},\n\trb: {\n\t\tparent: ['ruby', 'rtc'],\n\t},\n\trp: {\n\t\tparent: ['ruby', 'rtc'],\n\t},\n\trt: {\n\t\tcontent: TYPE_PHRASING,\n\t\tparent: ['ruby', 'rtc'],\n\t},\n\trtc: {\n\t\tcontent: TYPE_PHRASING,\n\t\tparent: ['ruby'],\n\t},\n\truby: {\n\t\tchildren: ['rb', 'rp', 'rt', 'rtc'],\n\t},\n\tsource: {\n\t\tparent: ['audio', 'video', 'picture'],\n\t\tvoid: true,\n\t},\n\tsummary: {\n\t\tcontent: TYPE_PHRASING,\n\t\tparent: ['details'],\n\t},\n\ttable: {\n\t\tchildren: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n\t\ttype: TYPE_FLOW,\n\t},\n\ttbody: {\n\t\tparent: ['table'],\n\t\tchildren: ['tr'],\n\t},\n\ttd: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['tr'],\n\t},\n\ttfoot: {\n\t\tparent: ['table'],\n\t\tchildren: ['tr'],\n\t},\n\tth: {\n\t\tcontent: TYPE_FLOW,\n\t\tparent: ['tr'],\n\t},\n\tthead: {\n\t\tparent: ['table'],\n\t\tchildren: ['tr'],\n\t},\n\ttr: {\n\t\tparent: ['table', 'tbody', 'thead', 'tfoot'],\n\t\tchildren: ['th', 'td'],\n\t},\n\ttrack: {\n\t\tparent: ['audio', 'video'],\n\t\tvoid: true,\n\t},\n\tul: {\n\t\tchildren: ['li'],\n\t\ttype: TYPE_FLOW,\n\t},\n\tvideo: {\n\t\tchildren: ['track', 'source'],\n\t},\n\twbr: {\n\t\ttype: TYPE_FLOW | TYPE_PHRASING,\n\t\tvoid: true,\n\t},\n};\n\nfunction createConfigBuilder(config: Partial<NodeConfig>): (tagName: string) => void {\n\treturn (tagName: string) => {\n\t\ttagConfigs[tagName] = {\n\t\t\t...config,\n\t\t\t...tagConfigs[tagName],\n\t\t};\n\t};\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_FLOW,\n\t\ttype: TYPE_FLOW | TYPE_PALPABLE,\n\t}),\n);\n\n[\n\t'abbr',\n\t'b',\n\t'bdi',\n\t'bdo',\n\t'cite',\n\t'code',\n\t'data',\n\t'dfn',\n\t'em',\n\t'i',\n\t'kbd',\n\t'mark',\n\t'q',\n\t'ruby',\n\t'samp',\n\t'strong',\n\t'sub',\n\t'sup',\n\t'time',\n\t'u',\n\t'var',\n].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_PHRASING,\n\t\ttype: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE,\n\t}),\n);\n\n['p', 'pre'].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_PHRASING,\n\t\ttype: TYPE_FLOW | TYPE_PALPABLE,\n\t}),\n);\n\n['s', 'small', 'span', 'del', 'ins'].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_PHRASING,\n\t\ttype: TYPE_FLOW | TYPE_PHRASING,\n\t}),\n);\n\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_FLOW,\n\t\ttype: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE,\n\t}),\n);\n\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(\n\tcreateConfigBuilder({\n\t\tcontent: TYPE_PHRASING,\n\t\ttype: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE,\n\t}),\n);\n\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(\n\tcreateConfigBuilder({\n\t\ttype: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE,\n\t}),\n);\n\n// Disable this map from being modified\nexport const TAGS: ConfigMap = Object.freeze(tagConfigs);\n\n// Tags that should never be allowed, even if the allow list is disabled\nexport const BANNED_TAG_LIST = [\n\t'applet',\n\t'base',\n\t'body',\n\t'command',\n\t'embed',\n\t'frame',\n\t'frameset',\n\t'head',\n\t'html',\n\t'link',\n\t'meta',\n\t'noscript',\n\t'object',\n\t'script',\n\t'style',\n\t'title',\n];\n\nexport const ALLOWED_TAG_LIST = Object.keys(TAGS).filter(\n\t(tag) => tag !== 'canvas' && tag !== 'iframe',\n);\n\n// Filters apply to HTML attributes\nexport const FILTER_ALLOW = 1;\nexport const FILTER_DENY = 2;\nexport const FILTER_CAST_NUMBER = 3;\nexport const FILTER_CAST_BOOL = 4;\nexport const FILTER_NO_CAST = 5;\n\n// Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\nexport const ATTRIBUTES: FilterMap = Object.freeze({\n\talt: FILTER_ALLOW,\n\tcite: FILTER_ALLOW,\n\tclass: FILTER_ALLOW,\n\tcolspan: FILTER_CAST_NUMBER,\n\tcontrols: FILTER_CAST_BOOL,\n\tdatetime: FILTER_ALLOW,\n\tdefault: FILTER_CAST_BOOL,\n\tdisabled: FILTER_CAST_BOOL,\n\tdir: FILTER_ALLOW,\n\theight: FILTER_ALLOW,\n\thref: FILTER_ALLOW,\n\tid: FILTER_ALLOW,\n\tkind: FILTER_ALLOW,\n\tlabel: FILTER_ALLOW,\n\tlang: FILTER_ALLOW,\n\tloading: FILTER_ALLOW,\n\tloop: FILTER_CAST_BOOL,\n\tmedia: FILTER_ALLOW,\n\tmuted: FILTER_CAST_BOOL,\n\tposter: FILTER_ALLOW,\n\trel: FILTER_ALLOW,\n\trole: FILTER_ALLOW,\n\trowspan: FILTER_CAST_NUMBER,\n\tscope: FILTER_ALLOW,\n\tsizes: FILTER_ALLOW,\n\tspan: FILTER_CAST_NUMBER,\n\tstart: FILTER_CAST_NUMBER,\n\tstyle: FILTER_NO_CAST,\n\tsrc: FILTER_ALLOW,\n\tsrclang: FILTER_ALLOW,\n\tsrcset: FILTER_ALLOW,\n\ttabindex: FILTER_ALLOW,\n\ttarget: FILTER_ALLOW,\n\ttitle: FILTER_ALLOW,\n\ttype: FILTER_ALLOW,\n\twidth: FILTER_ALLOW,\n});\n\n// Attributes to camel case for React props\nexport const ATTRIBUTES_TO_PROPS: Record<string, string> = Object.freeze({\n\tclass: 'className',\n\tcolspan: 'colSpan',\n\tdatetime: 'dateTime',\n\trowspan: 'rowSpan',\n\tsrclang: 'srcLang',\n\tsrcset: 'srcSet',\n\ttabindex: 'tabIndex',\n});\n", "import React from 'react';\nimport { ElementProps } from './types';\n\nexport function Element({\n\tattributes = {},\n\tclassName,\n\tchildren = null,\n\tselfClose = false,\n\ttagName,\n}: ElementProps) {\n\tconst Tag = tagName as 'span';\n\n\treturn selfClose ? (\n\t\t<Tag className={className} {...attributes} />\n\t) : (\n\t\t<Tag className={className} {...attributes}>\n\t\t\t{children}\n\t\t</Tag>\n\t);\n}\n", "import { ElementAttributes, FilterInterface } from './types';\n\nexport class Filter implements FilterInterface {\n\t/**\n\t * Filter and clean an HTML attribute value.\n\t */\n\tattribute<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] | null | undefined {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn value;\n\t}\n\n\t/**\n\t * Filter and clean an HTML node.\n\t */\n\tnode(name: string, node: HTMLElement): HTMLElement | null {\n\t\treturn node;\n\t}\n}\n", "import { MatchCallback, MatchResponse } from './types';\n\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\nexport function match<T>(\n\tstring: string,\n\tpattern: RegExp | string,\n\tprocess: MatchCallback<T>,\n\tisVoid: boolean = false,\n): MatchResponse<T> | null {\n\tconst matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tmatch: matches[0],\n\t\tvoid: isVoid,\n\t\t...process(matches),\n\t\tindex: matches.index!,\n\t\tlength: matches[0].length,\n\t\tvalid: true,\n\t};\n}\n", "import React from 'react';\nimport { match } from './match';\nimport { ChildrenNode, MatchCallback, MatcherInterface, MatchResponse, Node } from './types';\n\nexport abstract class Matcher<Props extends object = {}, Options extends object = {}>\n\timplements MatcherInterface<Props> {\n\tgreedy: boolean = false;\n\n\toptions: Options;\n\n\tpropName: string;\n\n\tinverseName: string;\n\n\tfactory: React.ComponentType<Props> | null;\n\n\tconstructor(name: string, options?: Options, factory?: React.ComponentType<Props> | null) {\n\t\tif (__DEV__ && (!name || name.toLowerCase() === 'html')) {\n\t\t\tthrow new Error(`The matcher name \"${name}\" is not allowed.`);\n\t\t}\n\n\t\t// @ts-expect-error Allow override\n\t\tthis.options = { ...options };\n\t\tthis.propName = name;\n\t\tthis.inverseName = `no${name.charAt(0).toUpperCase() + name.slice(1)}`;\n\t\tthis.factory = factory ?? null;\n\t}\n\n\t/**\n\t * Attempts to create a React element using a custom user provided factory,\n\t * or the default matcher factory.\n\t */\n\tcreateElement(children: ChildrenNode, props: Props): Node {\n\t\tconst element = this.factory\n\t\t\t? React.createElement(this.factory, props, children)\n\t\t\t: this.replaceWith(children, props);\n\n\t\tif (__DEV__ && typeof element !== 'string' && !React.isValidElement(element)) {\n\t\t\tthrow new Error(`Invalid React element created from ${this.constructor.name}.`);\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Trigger the actual pattern match and package the matched\n\t * response through a callback.\n\t */\n\tdoMatch<T>(\n\t\tstring: string,\n\t\tpattern: RegExp | string,\n\t\tcallback: MatchCallback<T>,\n\t\tisVoid: boolean = false,\n\t): MatchResponse<T> | null {\n\t\treturn match(string, pattern, callback, isVoid);\n\t}\n\n\t/**\n\t * Callback triggered before parsing.\n\t */\n\tonBeforeParse(content: string, props: Props): string {\n\t\treturn content;\n\t}\n\n\t/**\n\t * Callback triggered after parsing.\n\t */\n\tonAfterParse(content: Node[], props: Props): Node[] {\n\t\treturn content;\n\t}\n\n\t/**\n\t * Replace the match with a React element based on the matched token and optional props.\n\t */\n\tabstract replaceWith(children: ChildrenNode, props: Props): Node;\n\n\t/**\n\t * Defines the HTML tag name that the resulting React element will be.\n\t */\n\tabstract asTag(): string;\n\n\t/**\n\t * Attempt to match against the defined string. Return `null` if no match found,\n\t * else return the `match` and any optional props to pass along.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-redundant-type-constituents\n\tabstract match(string: string): MatchResponse<any> | null;\n}\n", "import { Filter } from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport class StyleFilter extends Filter {\n\toverride attribute<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\tif (name === 'style') {\n\t\t\tObject.keys(value).forEach((key) => {\n\t\t\t\tif (String(value[key]).match(INVALID_STYLES)) {\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\tdelete value[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn value;\n\t}\n}\n", "/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n\tALLOWED_TAG_LIST,\n\tATTRIBUTES,\n\tATTRIBUTES_TO_PROPS,\n\tBANNED_TAG_LIST,\n\tFILTER_CAST_BOOL,\n\tFILTER_CAST_NUMBER,\n\tFILTER_DENY,\n\tFILTER_NO_CAST,\n\tTAGS,\n} from './constants';\nimport { Element } from './Element';\nimport { StyleFilter } from './StyleFilter';\nimport {\n\tAttributes,\n\tAttributeValue,\n\tChildrenNode,\n\tElementAttributes,\n\tElementProps,\n\tFilterInterface,\n\tMatcherElementsMap,\n\tMatcherInterface,\n\tNode,\n\tNodeConfig,\n\tParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n\t// Maybe SSR? Just do nothing instead of crashing!\n\tif (typeof window === 'undefined' || typeof document === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\treturn document.implementation.createHTMLDocument('Interweave');\n}\n\nexport class Parser {\n\tallowed: Set<string>;\n\n\tbanned: Set<string>;\n\n\tblocked: Set<string>;\n\n\tcontainer?: HTMLElement;\n\n\tcontent: Node[] = [];\n\n\tprops: ParserProps;\n\n\tmatchers: MatcherInterface[];\n\n\tfilters: FilterInterface[];\n\n\tkeyIndex: number;\n\n\tconstructor(\n\t\tmarkup: string,\n\t\tprops: ParserProps = {},\n\t\tmatchers: MatcherInterface[] = [],\n\t\tfilters: FilterInterface[] = [],\n\t) {\n\t\tif (__DEV__ && markup && typeof markup !== 'string') {\n\t\t\tthrow new TypeError('Interweave parser requires a valid string.');\n\t\t}\n\n\t\tthis.props = props;\n\t\tthis.matchers = matchers;\n\t\tthis.filters = [...filters, new StyleFilter()];\n\t\tthis.keyIndex = -1;\n\t\tthis.container = this.createContainer(markup || '');\n\t\tthis.allowed = new Set(props.allowList ?? ALLOWED_TAG_LIST);\n\t\tthis.banned = new Set(BANNED_TAG_LIST);\n\t\tthis.blocked = new Set(props.blockList);\n\t}\n\n\t/**\n\t * Loop through and apply all registered attribute filters.\n\t */\n\tapplyAttributeFilters<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\treturn this.filters.reduce(\n\t\t\t(nextValue, filter) =>\n\t\t\t\tnextValue !== null && typeof filter.attribute === 'function'\n\t\t\t\t\t? filter.attribute(name, nextValue)\n\t\t\t\t\t: nextValue,\n\t\t\tvalue,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered node filters.\n\t */\n\tapplyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n\t\t// Allow null to be returned\n\t\treturn this.filters.reduce(\n\t\t\t(nextNode, filter) =>\n\t\t\t\tnextNode !== null && typeof filter.node === 'function'\n\t\t\t\t\t? filter.node(name, nextNode)\n\t\t\t\t\t: nextNode,\n\t\t\tnode,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered matchers to the string.\n\t * If a match is found, create a React element, and build a new array.\n\t * This array allows React to interpolate and render accordingly.\n\t */\n\tapplyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n\t\tconst elements: MatcherElementsMap = {};\n\t\tconst { props } = this;\n\t\tlet matchedString = string;\n\t\tlet elementIndex = 0;\n\t\tlet parts = null;\n\n\t\tthis.matchers.forEach((matcher) => {\n\t\t\tconst tagName = matcher.asTag().toLowerCase();\n\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t// Skip matchers that have been disabled from props or are not supported\n\t\t\tif ((props as Record<string, unknown>)[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip matchers in which the child cannot be rendered\n\t\t\tif (!this.canRenderChild(parentConfig, config)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Continuously trigger the matcher until no matches are found\n\t\t\tlet tokenizedString = '';\n\n\t\t\twhile (matchedString && (parts = matcher.match(matchedString))) {\n\t\t\t\tconst { index, length, match, valid, void: isVoid, ...partProps } = parts;\n\t\t\t\tconst tokenName = matcher.propName + String(elementIndex);\n\n\t\t\t\t// Piece together a new string with interpolated tokens\n\t\t\t\tif (index > 0) {\n\t\t\t\t\ttokenizedString += matchedString.slice(0, index);\n\t\t\t\t}\n\n\t\t\t\tif (valid) {\n\t\t\t\t\ttokenizedString += isVoid\n\t\t\t\t\t\t? `{{{${tokenName}/}}}`\n\t\t\t\t\t\t: `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\telementIndex += 1;\n\t\t\t\t\telements[tokenName] = {\n\t\t\t\t\t\tchildren: match,\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t...props,\n\t\t\t\t\t\t\t...partProps,\n\t\t\t\t\t\t\tkey: this.keyIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttokenizedString += match;\n\t\t\t\t}\n\n\t\t\t\t// Reduce the string being matched against,\n\t\t\t\t// otherwise we end up in an infinite loop!\n\t\t\t\tif (matcher.greedy) {\n\t\t\t\t\tmatchedString = tokenizedString + matchedString.slice(index + length);\n\t\t\t\t\ttokenizedString = '';\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line unicorn/explicit-length-check\n\t\t\t\t\tmatchedString = matchedString.slice(index + (length || match.length));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the matched string with the tokenized string,\n\t\t\t// so that the next matcher can apply to it.\n\t\t\tif (!matcher.greedy) {\n\t\t\t\tmatchedString = tokenizedString + matchedString;\n\t\t\t}\n\t\t});\n\n\t\tif (elementIndex === 0) {\n\t\t\treturn string;\n\t\t}\n\n\t\treturn this.replaceTokens(matchedString, elements);\n\t}\n\n\t/**\n\t * Determine whether the child can be rendered within the parent.\n\t */\n\tcanRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n\t\tif (!parentConfig.tagName || !childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// No children\n\t\tif (parentConfig.void) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid children\n\t\tif (parentConfig.children.length > 0) {\n\t\t\treturn parentConfig.children.includes(childConfig.tagName);\n\t\t}\n\n\t\tif (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid parent\n\t\tif (childConfig.parent.length > 0) {\n\t\t\treturn childConfig.parent.includes(parentConfig.tagName);\n\t\t}\n\n\t\t// Self nesting\n\t\tif (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Content category type\n\t\treturn Boolean(parentConfig && parentConfig.content & childConfig.type);\n\t}\n\n\t/**\n\t * Convert line breaks in a string to HTML `<br/>` tags.\n\t * If the string contains HTML, we should not convert anything,\n\t * as line breaks should be handled by `<br/>`s in the markup itself.\n\t */\n\tconvertLineBreaks(markup: string): string {\n\t\tconst { noHtml, disableLineBreaks } = this.props;\n\n\t\tif (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n\t\t\treturn markup;\n\t\t}\n\n\t\t// Replace carriage returns\n\t\tlet nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n\t\t// Replace long line feeds\n\t\tnextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n\t\t// Replace line feeds with `<br/>`s\n\t\tnextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n\t\treturn nextMarkup;\n\t}\n\n\t/**\n\t * Create a detached HTML document that allows for easy HTML\n\t * parsing while not triggering scripts or loading external\n\t * resources.\n\t */\n\tcreateContainer(markup: string): HTMLElement | undefined {\n\t\tconst factory =\n\t\t\t(typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n\t\tconst doc = factory();\n\n\t\tif (!doc) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst tag = this.props.containerTagName ?? 'body';\n\t\tconst el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n\t\tif (markup.match(INVALID_ROOTS)) {\n\t\t\tif (__DEV__) {\n\t\t\t\tthrow new Error('HTML documents as Interweave content are not supported.');\n\t\t\t}\n\t\t} else {\n\t\t\tel.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n\t\t}\n\n\t\treturn el;\n\t}\n\n\t/**\n\t * Convert an elements attribute map to an object map.\n\t * Returns null if no attributes are defined.\n\t */\n\textractAttributes(node: HTMLElement): Attributes | null {\n\t\tconst { allowAttributes } = this.props;\n\t\tconst attributes: Attributes = {};\n\t\tlet count = 0;\n\n\t\tif (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...node.attributes].forEach((attr: Attr) => {\n\t\t\tconst { name, value } = attr;\n\t\t\tconst newName = name.toLowerCase();\n\t\t\tconst filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n\t\t\t// Verify the node is safe from attacks\n\t\t\tif (!this.isSafe(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do not allow denied attributes, excluding ARIA attributes\n\t\t\t// Do not allow events or XSS injections\n\t\t\tif (\n\t\t\t\t!newName.match(ALLOWED_ATTRS) &&\n\t\t\t\t((!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n\t\t\t\t\tnewName.startsWith('on') ||\n\t\t\t\t\tvalue.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Apply attribute filters\n\t\t\tlet newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n\t\t\t// Cast to boolean\n\t\t\tif (filter === FILTER_CAST_BOOL) {\n\t\t\t\tnewValue = true;\n\n\t\t\t\t// Cast to number\n\t\t\t} else if (filter === FILTER_CAST_NUMBER) {\n\t\t\t\tnewValue = Number.parseFloat(String(newValue));\n\n\t\t\t\t// Cast to string\n\t\t\t} else if (filter !== FILTER_NO_CAST) {\n\t\t\t\tnewValue = String(newValue);\n\t\t\t}\n\n\t\t\tattributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n\t\t\t\tnewName as keyof ElementAttributes,\n\t\t\t\tnewValue,\n\t\t\t) as AttributeValue;\n\t\t\tcount += 1;\n\t\t});\n\n\t\tif (count === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * Extract the style attribute as an object and remove values that allow for attack vectors.\n\t */\n\textractStyleAttribute(node: HTMLElement): object {\n\t\tconst styles: Record<string, number | string> = {};\n\n\t\t// eslint-disable-next-line unicorn/prefer-spread\n\t\tArray.from(node.style).forEach((key) => {\n\t\t\tconst value = node.style[key as keyof CSSStyleDeclaration];\n\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tstyles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn styles;\n\t}\n\n\t/**\n\t * Return configuration for a specific tag.\n\t */\n\tgetTagConfig(tagName: string): NodeConfig {\n\t\tconst common = {\n\t\t\tchildren: [],\n\t\t\tcontent: 0,\n\t\t\tinvalid: [],\n\t\t\tparent: [],\n\t\t\tself: true,\n\t\t\ttagName: '',\n\t\t\ttype: 0,\n\t\t\tvoid: false,\n\t\t};\n\n\t\t// Only spread when a tag config exists,\n\t\t// otherwise we use the empty `tagName`\n\t\t// for parent config inheritance.\n\t\tif (TAGS[tagName]) {\n\t\t\treturn {\n\t\t\t\t...common,\n\t\t\t\t...TAGS[tagName],\n\t\t\t\ttagName,\n\t\t\t};\n\t\t}\n\n\t\treturn common;\n\t}\n\n\t/**\n\t * Verify that a node is safe from XSS and injection attacks.\n\t */\n\tisSafe(node: HTMLElement): boolean {\n\t\t// URLs should only support HTTP, email and phone numbers\n\t\tif (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n\t\t\tconst href = node.getAttribute('href');\n\n\t\t\t// Fragment protocols start with about:\n\t\t\t// So let's just allow them\n\t\t\tif (href?.startsWith('#')) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst protocol = node.protocol.toLowerCase();\n\n\t\t\treturn (\n\t\t\t\tprotocol === ':' ||\n\t\t\t\tprotocol === 'http:' ||\n\t\t\t\tprotocol === 'https:' ||\n\t\t\t\tprotocol === 'mailto:' ||\n\t\t\t\tprotocol === 'tel:'\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verify that an HTML tag is allowed to render.\n\t */\n\tisTagAllowed(tagName: string): boolean {\n\t\tif (this.banned.has(tagName) || this.blocked.has(tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\treturn this.props.allowElements || this.allowed.has(tagName);\n\t}\n\n\t/**\n\t * Parse the markup by injecting it into a detached document,\n\t * while looping over all child nodes and generating an\n\t * array to interpolate into JSX.\n\t */\n\tparse(): Node[] {\n\t\tif (!this.container) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n\t}\n\n\t/**\n\t * Loop over the nodes children and generate a\n\t * list of text nodes and React elements.\n\t */\n\tparseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n\t\tconst {\n\t\t\tnoHtml,\n\t\t\tnoHtmlExceptMatchers,\n\t\t\tallowElements,\n\t\t\ttransform,\n\t\t\ttransformOnlyAllowList,\n\t\t} = this.props;\n\t\tlet content: Node[] = [];\n\t\tlet mergedText = '';\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...parentNode.childNodes].forEach((node: ChildNode) => {\n\t\t\t// Create React elements from HTML elements\n\t\t\tif (node.nodeType === ELEMENT_NODE) {\n\t\t\t\tconst tagName = node.nodeName.toLowerCase();\n\t\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t\t// Persist any previous text\n\t\t\t\tif (mergedText) {\n\t\t\t\t\tcontent.push(mergedText);\n\t\t\t\t\tmergedText = '';\n\t\t\t\t}\n\n\t\t\t\t// Apply node filters first\n\t\t\t\tconst nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n\t\t\t\tif (!nextNode) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Apply transformation second\n\t\t\t\tlet children;\n\n\t\t\t\tif (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n\t\t\t\t\tthis.keyIndex += 1;\n\t\t\t\t\tconst key = this.keyIndex;\n\n\t\t\t\t\t// Must occur after key is set\n\t\t\t\t\tchildren = this.parseNode(nextNode, config);\n\n\t\t\t\t\tconst transformed = transform(nextNode, children, config);\n\n\t\t\t\t\tif (transformed === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof transformed !== 'undefined') {\n\t\t\t\t\t\tcontent.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset as we're not using the transformation\n\t\t\t\t\tthis.keyIndex = key - 1;\n\t\t\t\t}\n\n\t\t\t\t// Never allow these tags (except via a transformer)\n\t\t\t\tif (this.banned.has(tagName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Only render when the following criteria is met:\n\t\t\t\t//  - HTML has not been disabled\n\t\t\t\t//  - Tag is allowed\n\t\t\t\t//  - Child is valid within the parent\n\t\t\t\tif (\n\t\t\t\t\t!(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n\t\t\t\t\tthis.isTagAllowed(tagName) &&\n\t\t\t\t\t(allowElements || this.canRenderChild(parentConfig, config))\n\t\t\t\t) {\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\t// Build the props as it makes it easier to test\n\t\t\t\t\tconst attributes = this.extractAttributes(nextNode);\n\t\t\t\t\tconst elementProps: ElementProps = {\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\telementProps.attributes = attributes;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.void) {\n\t\t\t\t\t\telementProps.selfClose = config.void;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent.push(\n\t\t\t\t\t\tReact.createElement(\n\t\t\t\t\t\t\tElement,\n\t\t\t\t\t\t\t{ ...elementProps, key: this.keyIndex },\n\t\t\t\t\t\t\tchildren ?? this.parseNode(nextNode, config),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\t// Render the children of the current element only.\n\t\t\t\t\t// Important: If the current element is not allowed,\n\t\t\t\t\t// use the parent element for the next scope.\n\t\t\t\t} else {\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t...content,\n\t\t\t\t\t\t...this.parseNode(nextNode, config.tagName ? config : parentConfig),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Apply matchers if a text node\n\t\t\t} else if (node.nodeType === TEXT_NODE) {\n\t\t\t\tconst text =\n\t\t\t\t\tnoHtml && !noHtmlExceptMatchers\n\t\t\t\t\t\t? node.textContent\n\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\t\t\t\t\t  this.applyMatchers(node.textContent || '', parentConfig);\n\n\t\t\t\tif (Array.isArray(text)) {\n\t\t\t\t\tcontent = [...content, ...text];\n\t\t\t\t} else {\n\t\t\t\t\tmergedText += text!;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (mergedText) {\n\t\t\tcontent.push(mergedText);\n\t\t}\n\n\t\treturn content;\n\t}\n\n\t/**\n\t * Deconstruct the string into an array, by replacing custom tokens with React elements,\n\t * so that React can render it correctly.\n\t */\n\treplaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n\t\tif (!tokenizedString.includes('{{{')) {\n\t\t\treturn tokenizedString;\n\t\t}\n\n\t\tconst nodes: Node[] = [];\n\t\tlet text = tokenizedString;\n\t\tlet open: RegExpMatchArray | null = null;\n\n\t\t// Find an open token tag\n\t\twhile ((open = text.match(OPEN_TOKEN))) {\n\t\t\tconst [match, tokenName] = open;\n\t\t\tconst startIndex = open.index!;\n\t\t\tconst isVoid = match.includes('/');\n\n\t\t\tif (__DEV__ && !elements[tokenName]) {\n\t\t\t\tthrow new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n\t\t\t}\n\n\t\t\t// Extract the previous non-token text\n\t\t\tif (startIndex > 0) {\n\t\t\t\tnodes.push(text.slice(0, startIndex));\n\n\t\t\t\t// Reduce text so that the closing tag will be found after the opening\n\t\t\t\ttext = text.slice(startIndex);\n\t\t\t}\n\n\t\t\tconst { children, matcher, props: elementProps } = elements[tokenName];\n\t\t\tlet endIndex: number;\n\n\t\t\t// Use tag as-is if void\n\t\t\tif (isVoid) {\n\t\t\t\tendIndex = match.length;\n\n\t\t\t\tnodes.push(matcher.createElement(children, elementProps));\n\n\t\t\t\t// Find the closing tag if not void\n\t\t\t} else {\n\t\t\t\tconst close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n\t\t\t\tif (__DEV__ && !close) {\n\t\t\t\t\tthrow new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n\t\t\t\t}\n\n\t\t\t\tendIndex = close.index! + close[0].length;\n\n\t\t\t\tnodes.push(\n\t\t\t\t\tmatcher.createElement(\n\t\t\t\t\t\tthis.replaceTokens(text.slice(match.length, close.index), elements),\n\t\t\t\t\t\telementProps,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Reduce text for the next interation\n\t\t\ttext = text.slice(endIndex);\n\t\t}\n\n\t\t// Extra the remaining text\n\t\tif (text.length > 0) {\n\t\t\tnodes.push(text);\n\t\t}\n\n\t\t// Reduce to a string if possible\n\t\tif (nodes.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (nodes.length === 1 && typeof nodes[0] === 'string') {\n\t\t\treturn nodes[0];\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n", "/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport { Element } from './Element';\nimport { Parser } from './Parser';\nimport { MarkupProps } from './types';\n\nexport function Markup(props: MarkupProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontainerTagName,\n\t\tcontent,\n\t\temptyContent,\n\t\tparsedContent,\n\t\ttagName,\n\t\tnoWrap: baseNoWrap,\n\t} = props;\n\tconst tag = containerTagName ?? tagName ?? 'span';\n\tconst noWrap = tag === 'fragment' ? true : baseNoWrap;\n\tlet mainContent;\n\n\tif (parsedContent) {\n\t\tmainContent = parsedContent;\n\t} else {\n\t\tconst markup = new Parser(content ?? '', props).parse();\n\n\t\tif (markup.length > 0) {\n\t\t\tmainContent = markup;\n\t\t}\n\t}\n\n\tif (!mainContent) {\n\t\tmainContent = emptyContent;\n\t}\n\n\tif (noWrap) {\n\t\t// eslint-disable-next-line react/jsx-no-useless-fragment\n\t\treturn <React.Fragment>{mainContent}</React.Fragment>;\n\t}\n\n\treturn (\n\t\t<Element attributes={attributes} className={className} tagName={tag}>\n\t\t\t{mainContent}\n\t\t</Element>\n\t);\n}\n", "/* eslint-disable promise/prefer-await-to-callbacks */\nimport React from 'react';\nimport { Markup } from './Markup';\nimport { Parser } from './Parser';\nimport { InterweaveProps } from './types';\n\nexport function Interweave(props: InterweaveProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontent = '',\n\t\tdisableFilters = false,\n\t\tdisableMatchers = false,\n\t\temptyContent = null,\n\t\tfilters = [],\n\t\tmatchers = [],\n\t\tonAfterParse = null,\n\t\tonBeforeParse = null,\n\t\ttagName = 'span',\n\t\tnoWrap = false,\n\t\t...parserProps\n\t} = props;\n\tconst allMatchers = disableMatchers ? [] : matchers;\n\tconst allFilters = disableFilters ? [] : filters;\n\tconst beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n\tconst afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n\t// Inherit callbacks from matchers\n\tallMatchers.forEach((matcher) => {\n\t\tif (matcher.onBeforeParse) {\n\t\t\tbeforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n\t\t}\n\n\t\tif (matcher.onAfterParse) {\n\t\t\tafterCallbacks.push(matcher.onAfterParse.bind(matcher));\n\t\t}\n\t});\n\n\t// Trigger before callbacks\n\tconst markup = beforeCallbacks.reduce((string, callback) => {\n\t\tconst nextString = callback(string, props);\n\n\t\tif (__DEV__ && typeof nextString !== 'string') {\n\t\t\tthrow new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n\t\t}\n\n\t\treturn nextString;\n\t}, content ?? '');\n\n\t// Parse the markup\n\tconst parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n\t// Trigger after callbacks\n\tconst nodes = afterCallbacks.reduce((parserNodes, callback) => {\n\t\tconst nextNodes = callback(parserNodes, props);\n\n\t\tif (__DEV__ && !Array.isArray(nextNodes)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'Interweave `onAfterParse` must return an array of strings and React elements.',\n\t\t\t);\n\t\t}\n\n\t\treturn nextNodes;\n\t}, parser.parse());\n\n\treturn (\n\t\t<Markup\n\t\t\tattributes={attributes}\n\t\t\tclassName={className}\n\t\t\t// eslint-disable-next-line react/destructuring-assignment\n\t\t\tcontainerTagName={props.containerTagName}\n\t\t\temptyContent={emptyContent}\n\t\t\tnoWrap={noWrap}\n\t\t\tparsedContent={nodes.length === 0 ? undefined : nodes}\n\t\t\ttagName={tagName}\n\t\t/>\n\t);\n}\n"],
  "mappings": "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",
  "names": ["escapeHtml", "match", "TYPE_FLOW", "TYPE_SECTION", "TYPE_HEADING", "TYPE_PHRASING", "TYPE_EMBEDDED", "TYPE_INTERACTIVE", "TYPE_PALPABLE", "tagConfigs", "a", "content", "self", "type", "address", "invalid", "audio", "children", "br", "void", "body", "button", "caption", "parent", "col", "colgroup", "details", "dd", "dl", "dt", "figcaption", "footer", "header", "hr", "img", "li", "main", "ol", "picture", "rb", "rp", "rt", "rtc", "ruby", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "track", "ul", "video", "wbr", "createConfigBuilder", "config", "tagName", "forEach", "TAGS", "Object", "freeze", "BANNED_TAG_LIST", "ALLOWED_TAG_LIST", "keys", "filter", "tag", "FILTER_ALLOW", "FILTER_DENY", "FILTER_CAST_NUMBER", "FILTER_CAST_BOOL", "FILTER_NO_CAST", "ATTRIBUTES", "alt", "cite", "class", "colspan", "controls", "datetime", "default", "disabled", "dir", "height", "href", "id", "kind", "label", "lang", "loading", "loop", "media", "muted", "poster", "rel", "role", "rowspan", "scope", "sizes", "span", "start", "style", "src", "srclang", "srcset", "tabindex", "target", "title", "width", "ATTRIBUTES_TO_PROPS", "Element", "attributes", "className", "selfClose", "Tag", "React", "Filter", "attribute", "name", "value", "node", "matches", "string", "pattern", "RegExp", "match", "isVoid", "process", "index", "length", "valid", "greedy", "options", "propName", "factory", "constructor", "Error", "StyleFilter", "Filter", "attribute", "name", "value", "Object", "keys", "forEach", "key", "String", "match", "INVALID_STYLES", "TEXT_NODE", "INVALID_ROOTS", "ALLOWED_ATTRS", "OPEN_TOKEN", "undefined", "allowed", "banned", "blocked", "content", "matchers", "keyIndex", "constructor", "props", "_defineProperty", "TypeError", "allowList", "applyAttributeFilters", "filters", "reduce", "nextValue", "applyMatchers", "string", "parentConfig", "matcher", "canRenderChild", "valid", "void", "index", "tokenizedString", "elementIndex", "elements", "children", "greedy", "matchedString", "length", "childConfig", "noHtml", "disableLineBreaks", "replace", "nextMarkup", "global", "doc", "extractAttributes", "allowAttributes", "count", "attr", "filter", "node", "newName", "newValue", "extractStyleAttribute", "FILTER_CAST_BOOL", "attributes", "Array", "from", "styles", "getTagConfig", "tagName", "invalid", "parent", "self", "TAGS", "common", "isSafe", "href", "isTagAllowed", "parse", "parseNode", "noHtmlExceptMatchers", "transform", "transformOnlyAllowList", "ELEMENT_NODE", "mergedText", "config", "React", "elementProps", "replaceTokens", "open", "nodes", "text", "endIndex", "push", "slice", "className", "emptyContent", "parsedContent", "noWrap", "mainContent", "disableFilters", "onAfterParse", "onBeforeParse", "parserProps", "afterCallbacks", "allMatchers", "beforeCallbacks", "nextString", "parser", "markup", "isArray", "nextNodes"]
}
